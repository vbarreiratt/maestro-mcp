# Maestro MCP - Melhorias de Timing e Nota√ß√£o Musical

## üéØ Objetivo

Aprimorar as ferramentas MIDI existentes do servidor Maestro MCP para resolver problemas de timing e interpreta√ß√£o de partituras, **mantendo total compatibilidade com as implementa√ß√µes atuais**.

## üö® Problemas Identificados nos Testes

Durante os testes realizados com o sistema atual, identificamos os seguintes problemas:

### Teste 1: Melodia "Parab√©ns pra Voc√™"
```javascript
// Comando usado:
maestro:midi_play_phrase({
  notes: "C4 C4 D4 C4 F4 E4 C4 C4 D4 C4 G4 F4 C4 C4 C5 A4 F4 E4 D4 Bb4 Bb4 A4 F4 G4 F4",
  rhythm: "quarter quarter quarter quarter half half...",
  tempo: 120
})

// Problema: Timing impreciso, ritmo n√£o corresponde √† m√∫sica real
```

### Teste 2: Verso de "Oblivion" da Grimes
```javascript
// Tentativa 1:
maestro:midi_play_phrase({
  notes: "D4 F#4 A4 F#4 D4 F#4 B4 A4...",
  tempo: 158 // BPM correto da m√∫sica
})

// Problema: "os tempos ficaram estranhos" - feedback do usu√°rio
// Solu√ß√£o: Usu√°rio forneceu partitura para corre√ß√£o
```

### Teste 3: Sincroniza√ß√£o com GarageBand
```javascript
// Problema: MIDI enviado via IAC Driver n√£o sincronizava corretamente
// Usu√°rio teve que ajustar BPM manualmente no GarageBand
// Ainda assim: "ainda est√° um pouco estranho"
```

## ‚úÖ Solu√ß√£o: Melhorias Incrementais

### 1. Melhorar `midi_play_phrase` (Prioridade ALTA)

**Localiza√ß√£o:** `src/pilares/modulo midi/tradutor/transformers.ts`

**Mudan√ßas:**
- Adicionar parser de nota√ß√£o musical (`C4:q` = C4 quarter note)
- Melhorar c√°lculo de timing baseado em teoria musical
- Manter compatibilidade total com formato atual

**Implementa√ß√£o:**

```typescript
// Expandir interface existente (BACKWARDS COMPATIBLE)
interface PhraseOptions {
  notes: string; // Aceita AMBOS: "C4 E4 G4" E "C4:q E4:e G4:e"
  rhythm?: string | string[]; // Manter campo existente
  // NOVOS CAMPOS (opcionais):
  notation?: 'auto' | 'simple' | 'musical'; // Auto-detecta formato
  quantize?: boolean; // Corre√ß√£o autom√°tica de timing
  beatPositions?: number[]; // Timing preciso baseado em beats
  timeSignature?: [number, number]; // [4, 4] por padr√£o
}

// Nova fun√ß√£o no transformers.ts
function parseNotes(input: string, options: PhraseOptions): ParsedNote[] {
  // Detectar automaticamente o formato
  if (input.includes(':')) {
    return parseMusicalNotation(input); // "C4:q E4:e"
  }
  return parseSimpleNotation(input); // "C4 E4" (formato atual)
}

function parseMusicalNotation(input: string): ParsedNote[] {
  // Exemplo: "C4:q E4:e G4:e" ‚Üí [{note: 'C4', duration: 'quarter'}, ...]
  return input.split(' ').map(noteStr => {
    const [note, durationCode] = noteStr.split(':');
    const duration = DURATION_MAP[durationCode] || 'quarter';
    return { note, duration };
  });
}

const DURATION_MAP = {
  'w': 'whole',
  'h': 'half', 
  'q': 'quarter',
  'e': 'eighth',
  's': 'sixteenth'
};
```

### 2. Melhorar Timing no Maestro

**Localiza√ß√£o:** `src/pilares/modulo midi/maestro/scheduler.ts`

```typescript
// Adicionar √† classe existente
class TimingCalculator {
  static calculatePreciseDurations(
    rhythm: string[], 
    bpm: number, 
    timeSignature: [number, number] = [4, 4]
  ): number[] {
    const quarterNoteDuration = 60 / bpm; // segundos por quarter note
    
    const durationMap = {
      'whole': quarterNoteDuration * 4,
      'half': quarterNoteDuration * 2,
      'quarter': quarterNoteDuration,
      'eighth': quarterNoteDuration / 2,
      'sixteenth': quarterNoteDuration / 4
    };
    
    return rhythm.map(r => durationMap[r] || quarterNoteDuration);
  }
  
  static quantizeToMusicalGrid(
    positions: number[], 
    subdivision: 'quarter' | 'eighth' | 'sixteenth' = 'sixteenth'
  ): number[] {
    // Corrigir timing para grid musical mais pr√≥ximo
    const gridSize = {
      'quarter': 1,
      'eighth': 0.5,
      'sixteenth': 0.25
    }[subdivision];
    
    return positions.map(pos => 
      Math.round(pos / gridSize) * gridSize
    );
  }
}
```

### 3. Melhorar Detec√ß√£o de DAW no Mensageiro

**Localiza√ß√£o:** `src/pilares/modulo midi/mensageiro/port-manager.ts`

```typescript
// Expandir classe existente
class PortManager {
  // M√©todo existente mantido
  async listPorts(): Promise<PortInfo[]> { /* implementa√ß√£o atual */ }
  
  // NOVOS M√âTODOS:
  detectDAWs(): DAWInfo[] {
    const ports = this.listPorts();
    const daws = [];
    
    // Detectar GarageBand
    if (ports.some(p => p.name.includes('GarageBand'))) {
      daws.push({
        name: 'GarageBand',
        recommendedPort: ports.find(p => p.name.includes('GarageBand Virtual In')),
        optimalSettings: { latency: 'low', bufferSize: 256 }
      });
    }
    
    // Detectar outros DAWs...
    return daws;
  }
  
  suggestBestPort(targetDAW?: string): PortSuggestion {
    const daws = this.detectDAWs();
    if (targetDAW) {
      const daw = daws.find(d => d.name.toLowerCase().includes(targetDAW.toLowerCase()));
      return daw?.recommendedPort;
    }
    return daws[0]?.recommendedPort; // Melhor dispon√≠vel
  }
}
```

### 4. Nova Fun√ß√£o: `midi_import_score`

**Localiza√ß√£o:** `src/tools/midi-tools.ts`

```typescript
// NOVA ferramenta para importar partituras/tablaturas
export const midi_import_score = {
  name: "maestro:midi_import_score",
  description: "Importa partitura ou tablatura e converte para sequ√™ncia MIDI",
  inputSchema: {
    type: "object",
    properties: {
      source: {
        type: "string",
        enum: ["text_notation", "musicxml", "guitar_tab"],
        description: "Tipo de fonte musical"
      },
      data: {
        type: "string", 
        description: "Dados da partitura (nota√ß√£o musical, XML, ou tablatura)"
      },
      tempo: { type: "number", default: 120 },
      channel: { type: "number", default: 1 },
      preview: { type: "boolean", default: false }
    },
    required: ["source", "data"]
  },
  
  async handler(args) {
    const { source, data, tempo, channel, preview } = args;
    
    let sequence;
    switch (source) {
      case 'text_notation':
        // "A4:q B4:e A4:e | F4:h G4:q"
        sequence = parseTextNotation(data);
        break;
      case 'guitar_tab':
        // Converter tablatura em notas MIDI
        sequence = parseGuitarTab(data);
        break;
      // Adicionar outros formats futuramente
    }
    
    if (preview) {
      return { sequence, calculatedDuration: calculateTotalDuration(sequence, tempo) };
    }
    
    // Executar usando ferramentas existentes
    return await midi_play_phrase({
      notes: sequence.notes.join(' '),
      rhythm: sequence.rhythms,
      tempo,
      channel,
      quantize: true
    });
  }
};
```

## üìù Exemplos de Uso Melhorados

### Exemplo 1: Parab√©ns pra Voc√™ (Formato Novo)
```javascript
// NOVO formato com nota√ß√£o musical
maestro:midi_play_phrase({
  notes: "C4:q C4:q D4:q C4:q F4:h E4:h",
  tempo: 120,
  quantize: true // Corre√ß√£o autom√°tica de timing
})

// FORMATO ANTIGO ainda funciona
maestro:midi_play_phrase({
  notes: "C4 C4 D4 C4 F4 E4",
  rhythm: "quarter quarter quarter quarter half half",
  tempo: 120
})
```

### Exemplo 2: Oblivion com Partitura
```javascript
// Importar da partitura fornecida pelo usu√°rio
maestro:midi_import_score({
  source: "text_notation",
  data: "A4:q B4:e A4:e | A4:e G4:e F#4:e G4:h | A4:q A4:q A4:q A4:q",
  tempo: 156,
  channel: 1
})
```

### Exemplo 3: Configura√ß√£o Autom√°tica para GarageBand
```javascript
// NOVO: Detec√ß√£o autom√°tica
maestro:configure_midi_output({
  portName: "auto", // Detecta automaticamente o melhor
  targetDAW: "GarageBand"
})

// ANTIGO ainda funciona
maestro:configure_midi_output({
  portName: "GarageBand Virtual In"
})
```

## üîß Implementa√ß√£o por Fases

### Fase 1: Parser de Nota√ß√£o Musical (1-2 dias)
- [ ] Implementar `parseMusicalNotation()` em `tradutor/transformers.ts`
- [ ] Adicionar auto-detec√ß√£o de formato em `midi_play_phrase`
- [ ] Expandir schemas em `schemas/midi-schemas.ts`
- [ ] Testar com melodias simples

### Fase 2: Timing Preciso (1-2 dias)
- [ ] Implementar `TimingCalculator` em `maestro/scheduler.ts`
- [ ] Adicionar quantiza√ß√£o autom√°tica
- [ ] Melhorar c√°lculo de dura√ß√µes baseado em BPM
- [ ] Testar com "Oblivion" e "Parab√©ns pra Voc√™"

### Fase 3: Detec√ß√£o de DAW (1 dia)
- [ ] Implementar detec√ß√£o autom√°tica em `mensageiro/port-manager.ts`
- [ ] Adicionar sugest√µes de porta otimizadas
- [ ] Testar integra√ß√£o com GarageBand

### Fase 4: Import de Partituras (2-3 dias)
- [ ] Implementar `midi_import_score` em `tools/midi-tools.ts`
- [ ] Parser de tablatura de guitarra b√°sico
- [ ] Parser de nota√ß√£o musical estendida
- [ ] Integra√ß√£o com ferramentas existentes

## ‚úÖ Crit√©rios de Sucesso

1. **Compatibilidade Total**: Todas as ferramentas antigas funcionam exatamente como antes
2. **Timing Preciso**: Melodias como "Oblivion" soam corretas no tempo esperado
3. **Facilidade de Uso**: Nota√ß√£o musical intuitiva (`C4:q` em vez de arrays complexos)
4. **Integra√ß√£o DAW**: Configura√ß√£o autom√°tica para GarageBand e outros DAWs
5. **Flexibilidade**: Suporte tanto para casos simples quanto complexos

## üß™ Testes de Valida√ß√£o

```javascript
// Teste 1: Compatibilidade
const antigoFormato = await maestro.midi_play_phrase({
  notes: "C4 E4 G4",
  rhythm: "quarter quarter quarter",
  tempo: 120
});

// Teste 2: Novo formato
const novoFormato = await maestro.midi_play_phrase({
  notes: "C4:q E4:q G4:q",
  tempo: 120
});

// Teste 3: Auto-detec√ß√£o
const autoDetectado = await maestro.midi_play_phrase({
  notes: "C4:q E4 G4:h", // Formato misto
  tempo: 120,
  quantize: true
});

// Teste 4: Partitura complexa
const oblivion = await maestro.midi_import_score({
  source: "text_notation", 
  data: "A4:q B4:e A4:e | A4:e G4:e F#4:e G4:h",
  tempo: 156
});
```

---

**üí° Resultado Esperado:** Sistema robusto que resolve os problemas de timing identificados nos testes, mantendo total compatibilidade com implementa√ß√µes existentes e oferecendo funcionalidades avan√ßadas para casos complexos como partituras e sincroniza√ß√£o com DAWs.